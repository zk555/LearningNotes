#### 一、IP/TCP的通讯协议

##### 1. 网络领域知识

​	a) 、协议：tcp、udp、multicast

​	b) 、IO（BIO、NIO、AIO）

​	c) 、Socket

​	d) 、NIO(Netty/Mina)

​	e) 、序列化和反序列化

##### 2. 一个 http 请求，在整个网络中的请求过程

​		当应用程序用 T C P 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息。

![1600134855123](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600134855123.png)

​		当目的服务器收到数据时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每
层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用

![1600137625382](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600137625382.png)

##### 		3.为什么有了 MAC 层还要走 IP 层呢？

​			ip 地址表达的是当前机器在网络中的位置

​			mac确定到网段内指定的地址

##### 		4. 重点了解下 IP 协议和 TCP/UDP 协议

###### 			4.1 什么是协议？

​				协议相当于两个需要通过网络通信的程序达成的一种约定，它规定了报文的交换方式和包含的意义。

###### 			4.2 什么是IP协议			

​				TCP 和UDP 是两种最为著名的传输层协议，他们都是使用 I P 作为网络层协议。IP 协议提供了一组数据报文服务，每组分组报文都是由网络独立处理和分发，每个 IP 报文必须包含一个目的地址的字段， IP 协议只是一个“尽力而为”的协议，在网络传输过程中，可能会发生报文丢失、报文顺序打乱，重复发送的情况。IP 协议层之上的传输层，提供了两种可以选择的协议，TCP、UPD。这两种协议都是建立在 IP 层所提供的服务基础上，根据应用程序的不同需求选择不同方式的传输；

###### 			4.3 TCP /IP （数据传输安全）

​				TCP协议能够检测和恢复IP层提供的主机到主机的通信中可能发生的报文丢失、重复及其他错误。TCP 提供了一个可信赖的字节流通道，这样应用程序就不需要考虑这些问题。

​				由于需要创建管道，需要进行3次握手建立连接

###### 			4.4 UDP/IP

​				UDP 协议不会对 IP 层产生的错误进行修复，而是简单的扩展了 IP 协议“尽力而为”的数据报文服务，使他能够在应用程序之间工作，而不是在主机之间工作，因此使用 UDP协议必须要考虑到报文丢失，顺序混乱的问题

#####  		5. TCP 是如何做到可靠传输的？			

**建立可靠的链接**	

​			由于 TCP 协议是一种可信的传输协议，所以在传输之前，需要通过三次握手建立一个连接，所谓的三次握手，就是在建立 TCP 链接时，需要客户端和服务端总共发送 3个包来确认连接的建立

​		![1600141731190](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600141731190.png)

​			第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

​			第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；			

​			第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

**SYN攻击原理：**SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。

**TCP四次挥手**

​			![1600153098992](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600153098992.png)

​				四次挥手表示 **TCP 断开连接的时候,需要客户端和服务端总共发送 4 个包**以确认连接的断开；客户端或服务器均可主动发起挥手动作(因为 TCP 是一个全双工协议)，在socket 编程中，任何一方执行 close() 操作即可产生挥手操作。

​		**tips:为什么连接的时候是三次握手，关闭的时候却是四次握手？**

​		三次握手是因为因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK报文是用来应答的，SYN 报文是用来同步的。

​		但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET（因为可能还有消息没处理完），所以只能先回复一个 ACK 报文，告诉 Client 端，"你发的 FIN 报文我收到了"。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。

##### 	6. 数据传输过程的流量控制和确认

​		建立可靠连接以后，就开始进行数据传输了。利用滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。TCP 的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。

###### 		6.1 滑动窗口协议

​		![1600153696325](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600153696325.png)

​		  	发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞。下面图中的4,5,6 号数据帧已经被发送出去，但是未收到关联的ACK，7,8,9 帧则是等待发送。可以看出发送端的窗口大小为 6，这是由接受端告知的。此时如果发送端收到 4 号ACK，则窗口的左边缘向右收缩，窗口的右边缘则向右扩展，此时窗口就向前“滑动了”，即数据帧 10 也可以被发送。

###### 		6.2 发送窗口

​				就是发送端允许连续发送的幀的序号表。发送端可以不等待应答而连续发送的最大幀数称为发送窗口的尺寸。

###### 	   6.3 接收窗口

​				接收方允许接收的幀的序号表，凡落在 接收窗口内的幀，接收方都必须处理，落在接收窗口外的幀被丢弃。接收方每次允许接收的幀数称为接收窗口的尺寸。

##### 7. 通信的性能问题？

​	正常的通信过程如下(BIO)

​		![1600154303644](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600154303644.png)

​			迭代服务器是按照顺序处理客户端请求，也就是服务端必须要处理完前一个请求才能对下一个客户端的请求进行响应。

###### 			7.1 如何提高性能	

​			TCP  Socket的内核通信过程中都有一个发送缓冲区和一个接收缓冲区，TCP 的全双工的工作模式及 TCP 的滑动窗口就是依赖于这两个独立的 Buffer 和该Buffer 的填充状态。

​			接收缓冲区把数据缓存到内核，若应用进程一直没有调用Socket 的 read 方法进行读取，那么该数据会一直被缓存在接收缓冲区内。	

​			read 所要做的工作，就是把内核接收缓冲区中的数据复制到应用层用户的 Buffer 里		

​			send 发送数据的时候，一般情况下是将数据从应用层用户的 Buffer 里复制到 Socket 的内核发送缓冲区，然后 send 就会在上层返回。换句话说，send 返回时，数据不一定会被发送到对端。

![1600154831197](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600154831197.png)

###### 				7.2 如何使用非阻塞提高性能？

​			非阻塞要解决的就是 I/O 线程与 Socket 解耦的问题，因此，它引入了事件机制来达到解耦的目的。

​			我们可以认为NIO 底层中存在一个 I/O 调度线程，它不断的扫描每个Socket 的缓冲区，当发现写入缓冲区为空的时候，它会产生一个 Socket 可写事件，此时程序就可以把数据写入到 Socket 中。如果一次写不完，就等待下一次的可写事件通知；反之，当发现缓冲区里有数据的时候，它会产生一个 Socket 可读事件，程序收到这个通知事件就可以从Socket 读取数据了。

###### 				7.3 缓冲区

​			在 NIO 中，所有数据都是用缓冲区处理，在读取数据的时候，它是直接读到缓冲区中，在写如数据的时候，也是写到缓冲区。任何时候访问 NIO 中的数据，都是通过缓冲区进行的操作

###### 				7.4 通道

​			Channel 通道，就像一个自来水管一样，可以通过它读取和写入数据，Channel 是全双工的，所以数据是双向流动。

###### 				7.5 多路复用

![1600155508032](C:\Users\zhao\AppData\Roaming\Typora\typora-user-images\1600155508032.png)

​			多路复用器 Selector，是 NIO 的基础，多路复用器提供选择已经就绪的任务的能力，简单来说，Selector 会不断轮询注册上的 Channel，如果某个 Channel 上面有新的 TCP连接接入、读、写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来，然后通过 SelectionKey 可以获取就绪的 Channel 进行 I/O 操作；一个多路复用器可以同时轮询多个 Channel。通过这个机制可以接入成千上万的客户端。

